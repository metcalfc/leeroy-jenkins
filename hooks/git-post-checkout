#!/usr/bin/env bash
# Git hook: post-checkout
# Clears AI session when switching branches to prevent contamination
#
# Arguments passed by git:
#   $1 - ref of previous HEAD
#   $2 - ref of new HEAD
#   $3 - flag (1 = branch checkout, 0 = file checkout)

set -e

PREV_HEAD="$1"
NEW_HEAD="$2"
BRANCH_CHECKOUT="$3"

SESSION_FILE="${HOME}/.leeroy/current-session.json"

# Only act on branch checkouts, not file checkouts
if [[ "$BRANCH_CHECKOUT" != "1" ]]; then
    exit 0
fi

# Check if AI session exists
if [[ ! -f "$SESSION_FILE" ]]; then
    exit 0
fi

# Get previous and new branch names
prev_branch=$(git name-rev --name-only "$PREV_HEAD" 2>/dev/null || echo "unknown")
new_branch=$(git name-rev --name-only "$NEW_HEAD" 2>/dev/null || echo "unknown")

# If switching to the same branch (e.g., during rebase), don't clear
if [[ "$prev_branch" == "$new_branch" ]]; then
    exit 0
fi

# Parse session to check if there's any uncommitted AI work
if command -v jq &> /dev/null; then
    files_count=$(jq -r '.files_modified | length' "$SESSION_FILE" 2>/dev/null || echo "0")
    prompts_count=$(jq -r '.prompts | length' "$SESSION_FILE" 2>/dev/null || echo "0")

    # Only warn if there's actual activity
    if [[ "$files_count" != "0" || "$prompts_count" != "0" ]]; then
        echo "⚠️  Branch switch detected with active AI session"
        echo "   Previous branch: $prev_branch"
        echo "   New branch: $new_branch"
        echo "   Files modified: $files_count, Prompts: $prompts_count"
        echo "   Clearing session to prevent contamination..."
    fi
fi

# Clear session
rm -f "$SESSION_FILE"

# Also clear prompts log if it exists
PROMPTS_LOG="${HOME}/.leeroy/prompts.log"
if [[ -f "$PROMPTS_LOG" ]]; then
    rm -f "$PROMPTS_LOG"
fi

exit 0
