name: PR Gatekeeper

# We use pull_request_target instead of pull_request because:
# 1. PRs from forks get read-only GITHUB_TOKEN with pull_request (security feature)
# 2. This workflow needs write access to add labels and post comments
# 3. This is SAFE because we only read git commit metadata - we don't checkout or
#    execute any code from the PR. The attestation check uses git rev-list on
#    commit messages only.
on:
  pull_request_target:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  validate-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # With pull_request_target, we only get the base branch. Fetch the PR head
      # so git rev-list can access those commits. We don't checkout the PR code,
      # just fetch it for reading commit metadata.
      - name: Fetch PR head
        run: git fetch origin ${{ github.event.pull_request.head.sha }}

      - name: Check author permissions
        id: check-author
        uses: actions/github-script@v7
        with:
          script: |
            const author = context.payload.pull_request.user.login;
            console.log(`PR author: ${author}`);

            try {
              // Check if the author has write (push) access to the repository
              const { data: permissionLevel } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: author
              });

              const permission = permissionLevel.permission;
              console.log(`Author permission level: ${permission}`);

              // write, maintain, and admin all have write access
              const hasWriteAccess = ['write', 'maintain', 'admin'].includes(permission);

              core.setOutput('author', author);
              core.setOutput('permission', permission);
              core.setOutput('has_write_access', hasWriteAccess.toString());

              return hasWriteAccess;
            } catch (error) {
              // If we can't check permissions (e.g., first-time contributor), assume no access
              console.log(`Could not check permissions: ${error.message}`);
              core.setOutput('author', author);
              core.setOutput('permission', 'none');
              core.setOutput('has_write_access', 'false');
              return false;
            }

      - name: Check commits for Leeroy attestation
        id: check-attestation
        run: |
          BASE_SHA=${{ github.event.pull_request.base.sha }}
          HEAD_SHA=${{ github.event.pull_request.head.sha }}

          echo "Checking commits from ${BASE_SHA:0:8} to ${HEAD_SHA:0:8}"

          total=0
          attested=0
          ai_attested=0
          human_attested=0
          unattested_commits=""
          attested_commits=""

          for sha in $(git rev-list ${BASE_SHA}..${HEAD_SHA}); do
            ((total++)) || true
            short_sha="${sha:0:8}"
            subject=$(git log -1 --format="%s" ${sha})

            # Check commit message for Leeroy attestation (today version)
            commit_body=$(git log -1 --format="%b" ${sha})

            if echo "${commit_body}" | grep -q "^AI-Assisted: true"; then
              ((attested++)) || true
              ((ai_attested++)) || true
              attested_commits="${attested_commits}${short_sha} [AI] ${subject}\n"
              echo "âœ… ${short_sha}: Has AI attestation"
            elif echo "${commit_body}" | grep -q "^Human-Attested: true"; then
              ((attested++)) || true
              ((human_attested++)) || true
              attested_commits="${attested_commits}${short_sha} [Human] ${subject}\n"
              echo "âœ… ${short_sha}: Has human attestation"
            else
              unattested_commits="${unattested_commits}${short_sha} ${subject}\n"
              echo "âŒ ${short_sha}: No attestation"
            fi
          done

          echo "ai_attested=${ai_attested}" >> $GITHUB_OUTPUT
          echo "human_attested=${human_attested}" >> $GITHUB_OUTPUT

          echo "total=${total}" >> $GITHUB_OUTPUT
          echo "attested=${attested}" >> $GITHUB_OUTPUT

          # All commits must have attestation for full coverage
          if [[ ${total} -gt 0 && ${attested} -eq ${total} ]]; then
            echo "all_attested=true" >> $GITHUB_OUTPUT
          else
            echo "all_attested=false" >> $GITHUB_OUTPUT
          fi

          # At least some commits have attestation
          if [[ ${attested} -gt 0 ]]; then
            echo "has_attestation=true" >> $GITHUB_OUTPUT
          else
            echo "has_attestation=false" >> $GITHUB_OUTPUT
          fi

          # Store commit lists for the comment
          echo "attested_commits<<EOF" >> $GITHUB_OUTPUT
          echo -e "${attested_commits}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "unattested_commits<<EOF" >> $GITHUB_OUTPUT
          echo -e "${unattested_commits}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Check commit signatures
        id: check-signatures
        uses: actions/github-script@v7
        with:
          script: |
            // Use GitHub API for signature verification - works for GPG, SSH, and S/MIME
            // Local git verification fails for SSH signatures without gpg.ssh.allowedSignersFile
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            console.log(`Checking signatures for ${commits.length} commits`);

            let total = 0;
            let signed = 0;
            let signatureDetails = [];

            for (const commit of commits) {
              total++;
              const shortSha = commit.sha.slice(0, 8);
              const subject = commit.commit.message.split('\n')[0];
              const verification = commit.commit.verification;

              if (verification && verification.verified) {
                signed++;
                const reason = verification.reason || 'verified';
                signatureDetails.push(`${shortSha} [âœ… ${reason}] ${subject}`);
                console.log(`âœ… ${shortSha}: Verified (${reason})`);
              } else {
                const reason = verification ? verification.reason : 'unsigned';
                signatureDetails.push(`${shortSha} [âŒ ${reason}] ${subject}`);
                console.log(`âŒ ${shortSha}: Not verified (${reason})`);
              }
            }

            core.setOutput('signed', signed);
            core.setOutput('total', total);
            core.setOutput('all_signed', total > 0 && signed === total);
            core.setOutput('has_signatures', signed > 0);
            core.setOutput('signature_details', signatureDetails.join('\n'));

      - name: Evaluate PR status
        id: evaluate
        run: |
          has_write="${{ steps.check-author.outputs.has_write_access }}"
          has_attestation="${{ steps.check-attestation.outputs.has_attestation }}"
          all_attested="${{ steps.check-attestation.outputs.all_attested }}"

          echo "Author has write access: ${has_write}"
          echo "Has any attestation: ${has_attestation}"
          echo "All commits attested: ${all_attested}"

          # Determine if PR should pass
          # Pass if: author has write access OR any commits have attestation
          if [[ "${has_write}" == "true" ]]; then
            echo "status=approved" >> $GITHUB_OUTPUT
            echo "reason=trusted_contributor" >> $GITHUB_OUTPUT
            echo "âœ… PR approved: Author is a trusted contributor with write access"
          elif [[ "${all_attested}" == "true" ]]; then
            echo "status=approved" >> $GITHUB_OUTPUT
            echo "reason=full_attestation" >> $GITHUB_OUTPUT
            echo "âœ… PR approved: All commits have Leeroy AI attestation"
          elif [[ "${has_attestation}" == "true" ]]; then
            echo "status=approved" >> $GITHUB_OUTPUT
            echo "reason=partial_attestation" >> $GITHUB_OUTPUT
            echo "âœ… PR approved: Some commits have Leeroy AI attestation"
          else
            echo "status=rejected" >> $GITHUB_OUTPUT
            echo "reason=no_attestation" >> $GITHUB_OUTPUT
            echo "âŒ PR rejected: No write access and no Leeroy attestation"
          fi

          # Determine labels - trust level AND attestation type are separate
          ai_count="${{ steps.check-attestation.outputs.ai_attested }}"
          human_count="${{ steps.check-attestation.outputs.human_attested }}"

          # Trust label (based on author permissions)
          if [[ "${has_write}" == "true" ]]; then
            echo "trust_label=trusted-contributor" >> $GITHUB_OUTPUT
          else
            echo "trust_label=" >> $GITHUB_OUTPUT
          fi

          # Attestation label (based on commit attestations)
          if [[ "${all_attested}" == "true" ]]; then
            if [[ "${ai_count}" -gt 0 && "${human_count}" -gt 0 ]]; then
              echo "attestation_label=attested-mixed" >> $GITHUB_OUTPUT
            elif [[ "${ai_count}" -gt 0 ]]; then
              echo "attestation_label=ai-assisted" >> $GITHUB_OUTPUT
            else
              echo "attestation_label=human-attested" >> $GITHUB_OUTPUT
            fi
          elif [[ "${has_attestation}" == "true" ]]; then
            echo "attestation_label=attested-partial" >> $GITHUB_OUTPUT
          else
            echo "attestation_label=no-attestation" >> $GITHUB_OUTPUT
          fi

      - name: Add labels
        uses: actions/github-script@v7
        with:
          script: |
            const trustLabel = '${{ steps.evaluate.outputs.trust_label }}';
            const attestationLabel = '${{ steps.evaluate.outputs.attestation_label }}';
            const allSigned = '${{ steps.check-signatures.outputs.all_signed }}' === 'true';

            // Label definitions with colors and descriptions
            const labelDefs = {
              'trusted-contributor': {
                color: '238636',  // green
                description: 'PR author has write access to this repository'
              },
              'ai-assisted': {
                color: 'a371f7',  // purple
                description: 'All commits have AI attestation via Leeroy'
              },
              'human-attested': {
                color: '1f6feb',  // blue
                description: 'All commits attested as human-authored'
              },
              'attested-mixed': {
                color: '3fb950',  // teal
                description: 'Mix of AI-assisted and human-attested commits'
              },
              'attested-partial': {
                color: 'd29922',  // yellow/orange
                description: 'Some commits have attestation'
              },
              'no-attestation': {
                color: 'da3633',  // red
                description: 'No commits have Leeroy attestation'
              },
              'signed-commits': {
                color: '238636',  // green
                description: 'All commits are cryptographically signed'
              }
            };

            const managedLabels = Object.keys(labelDefs);

            // Ensure labels exist with correct colors
            async function ensureLabel(name) {
              const def = labelDefs[name];
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: name
                });
                // Label exists, update color if needed
                await github.rest.issues.updateLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: name,
                  color: def.color,
                  description: def.description
                });
              } catch (e) {
                if (e.status === 404) {
                  // Label doesn't exist, create it
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: name,
                    color: def.color,
                    description: def.description
                  });
                  console.log(`Created label: ${name}`);
                }
              }
            }

            // Remove any existing managed labels first
            const existingLabels = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const labelsToRemove = existingLabels.data
              .filter(l => managedLabels.includes(l.name))
              .map(l => l.name);

            for (const oldLabel of labelsToRemove) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: oldLabel
              }).catch(() => {}); // Ignore if label doesn't exist
            }

            // Build label list - add all applicable labels
            const labelsToAdd = [];

            // Trust level label
            if (trustLabel) {
              labelsToAdd.push(trustLabel);
            }

            // Attestation type label
            if (attestationLabel) {
              labelsToAdd.push(attestationLabel);
            }

            // Signature label
            if (allSigned) {
              labelsToAdd.push('signed-commits');
            }

            // Ensure labels exist with proper colors, then add them
            if (labelsToAdd.length > 0) {
              for (const label of labelsToAdd) {
                await ensureLabel(label);
              }
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: labelsToAdd
              });
              console.log(`Applied labels: ${labelsToAdd.join(', ')}`);
            } else {
              console.log('No labels to apply');
            }

      - name: Post status comment
        uses: actions/github-script@v7
        with:
          script: |
            const author = '${{ steps.check-author.outputs.author }}';
            const permission = '${{ steps.check-author.outputs.permission }}';
            const hasWriteAccess = '${{ steps.check-author.outputs.has_write_access }}' === 'true';
            const status = '${{ steps.evaluate.outputs.status }}';
            const reason = '${{ steps.evaluate.outputs.reason }}';
            const total = parseInt('${{ steps.check-attestation.outputs.total }}') || 0;
            const attested = parseInt('${{ steps.check-attestation.outputs.attested }}') || 0;
            const aiAttested = parseInt('${{ steps.check-attestation.outputs.ai_attested }}') || 0;
            const humanAttested = parseInt('${{ steps.check-attestation.outputs.human_attested }}') || 0;
            const attestedCommits = `${{ steps.check-attestation.outputs.attested_commits }}`.trim();
            const unattestedCommits = `${{ steps.check-attestation.outputs.unattested_commits }}`.trim();
            const signed = parseInt('${{ steps.check-signatures.outputs.signed }}') || 0;
            const allSigned = '${{ steps.check-signatures.outputs.all_signed }}' === 'true';
            const signatureDetails = `${{ steps.check-signatures.outputs.signature_details }}`.trim();

            const isApproved = status === 'approved';
            const icon = isApproved ? 'âœ…' : 'âŒ';
            const title = isApproved ? 'PR Approved' : 'PR Requires Attention';

            let body = `## ${icon} PR Gatekeeper: ${title}\n\n`;

            // Author info
            body += `### Contributor Status\n`;
            body += `- **Author:** @${author}\n`;
            body += `- **Permission Level:** ${permission}\n`;
            body += `- **Write Access:** ${hasWriteAccess ? 'âœ… Yes' : 'âŒ No'}\n\n`;

            // Attestation info
            body += `### Attestation Status\n`;
            body += `- **Total attested commits:** ${attested}/${total}\n`;
            if (aiAttested > 0) body += `  - ðŸ¤– AI-assisted: ${aiAttested}\n`;
            if (humanAttested > 0) body += `  - ðŸ‘¤ Human-attested: ${humanAttested}\n`;
            body += '\n';

            // Signature info
            body += `### Signature Status\n`;
            body += `- **Signed commits:** ${signed}/${total} ${allSigned ? 'âœ…' : ''}\n`;
            if (signatureDetails) {
              body += `\n<details>\n<summary>Signature details</summary>\n\n`;
              signatureDetails.split('\n').filter(Boolean).forEach(c => {
                body += `- \`${c}\`\n`;
              });
              body += `\n</details>\n`;
            }
            body += '\n';

            if (attestedCommits) {
              body += `**Attested commits:**\n`;
              attestedCommits.split('\n').filter(Boolean).forEach(c => {
                body += `- âœ… \`${c}\`\n`;
              });
              body += '\n';
            }

            if (unattestedCommits) {
              body += `**Commits without attestation:**\n`;
              unattestedCommits.split('\n').filter(Boolean).forEach(c => {
                body += `- âŒ \`${c}\`\n`;
              });
              body += '\n';
            }

            // Decision explanation
            body += `### Decision\n`;
            switch (reason) {
              case 'trusted_contributor':
                body += `âœ… **Approved:** @${author} is a trusted contributor with write access to this repository.\n`;
                break;
              case 'full_attestation':
                if (aiAttested > 0 && humanAttested > 0) {
                  body += `âœ… **Approved:** All commits are attested (${aiAttested} AI-assisted, ${humanAttested} human-authored).\n`;
                } else if (humanAttested > 0) {
                  body += `âœ… **Approved:** All commits are attested as human-authored (no AI assistance).\n`;
                } else {
                  body += `âœ… **Approved:** All commits include Leeroy AI attestation, providing full transparency.\n`;
                }
                break;
              case 'partial_attestation':
                body += `âœ… **Approved:** Some commits include attestation. `;
                body += `Consider adding attestation to all commits for complete transparency.\n`;
                break;
              case 'no_attestation':
                body += `âŒ **Rejected:** Author does not have write access and no commits include attestation.\n\n`;
                body += `**To fix:**\n`;
                body += `1. Install [Leeroy](https://github.com/metcalfc/leeroy-jenkins) to add attestation to your commits\n`;
                body += `2. For AI-assisted commits: attestation is added automatically\n`;
                body += `3. For human-authored commits: run \`leeroy attest-human\` after committing\n`;
                body += `4. Or request write access to this repository\n`;
                break;
            }

            body += `\n---\n*This check is powered by [Leeroy Toolkit](https://github.com/metcalfc/leeroy-jenkins) - transparent attribution for AI-assisted code.*`;

            // Find and update existing comment or create new one
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = comments.data.find(c =>
              c.user.type === 'Bot' && c.body.includes('PR Gatekeeper')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: Fail if rejected
        if: steps.evaluate.outputs.status == 'rejected'
        run: |
          echo "::error::PR rejected: ${{ steps.evaluate.outputs.reason }}"
          echo ""
          echo "This PR was rejected because:"
          echo "  - Author does not have write access to this repository"
          echo "  - No commits include Leeroy AI attestation"
          echo ""
          echo "To resolve this:"
          echo "  1. Install Leeroy (https://github.com/metcalfc/leeroy-jenkins)"
          echo "  2. Recommit with AI attestation enabled"
          echo "  - OR request write access from repository maintainers"
          exit 1
